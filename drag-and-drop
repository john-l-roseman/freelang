Dataset Fields: id | text (English) | translation (LANGUAGE Translation) | audio (set explicitly to null)
Elminate any duplicates in the dataset.

Act as an expert Frontend Engineer. 
Build a single, standalone HTML file (index.html) for a language learning game.
IMPORTANT: Do not add any notes, markdown, or explanations at the top or bottom of the HTML file. Output ONLY the raw HTML.

1. GLOBAL CONFIGURATION
-----------------------
- CARDS_PER_ROUND: _CARD_COUNT
- BASE_LANGUAGE: _BASE_LANGUAGE
- TARGET_LANGUAGE: _TARGET_LANGUAGE
- LANGUAGE_CODE: Two letter standard code for _TARGET_LANGUAGE (All Caps).
- GA_MEASUREMENT_ID: "G-WFWF326Q9H"  


2. TECHNICAL STACK & SETUP
--------------------------
- React, ReactDOM, Babel (via CDN).
- TailwindCSS (via CDN).
- Embed all CSS/JS within the file.
- Analytics: Include the standard Google Analytics 4 (gtag.js) script in the <head>. Initialize `window.dataLayer` and config using the `GA_MEASUREMENT_ID`. 
- PWA: Include an embedded `manifest.json` (Blob) and Service Worker.
- PWA Icon: Generate a Base64 SVG (Green square, white text "LANGUAGE_CODE") for the manifest. Short name: "_GAME".
- Cache Control: You MUST include the following three <meta> tags in the <head> to prevent client-side caching:
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">


3. ARCHITECTURE & STATE MANAGEMENT (CRITICAL)
---------------------------------------------
- Storage Key: Use const `STORAGE_KEY = 'openlang__LANGUAGE_Beginner_progress'`.
- Persistence Schema: `{ score: number, streak: number, learnedIds: [] }`.
- Initialization Logic (Order of Operations):
  1. On mount, read `localStorage`.
  2. If data exists, hydrate `score` and `streak` state from it.
  3. Filter `RAW_DATA` to exclude any IDs found in `learnedIds`.
  4. Initialize `deckRef` using a Fisher-Yates shuffle of the *remaining* (unlearned) items.
  5. If no items remain (all learned), trigger the Win Condition immediately.
  6. If items remain, call `startRound()` to load the first batch.
- Round State: Use `useState` (`roundData`) for the current CARDS_PER_ROUND pairs.
- Mastery Logic: When a match is made (no hint), remove the word from `deckRef.current` immediately.
- Round Transition (useEffect Pattern): 
  - You MUST use a `useEffect` hook to handle transitions. Do NOT trigger the next round inside `handleMatch`.
  - Watch dependency: `[roundData.left.length, isWon]`.
  - Logic: IF `roundData.left.length === 0` AND `!isWon` AND `deckRef.current` is initialized:
    a. Check if `deckRef.current.length > 0`.
    b. If YES: Call `startRound()`.
    c. If NO: Set `isWon(true)`.
- _LANGUAGE Column Logic: Must be a VALID DERANGEMENT (shuffled so no _LANGUAGE card lines up horizontally with its English counterpart). If batch size < 2, return as-is.


4. LAYOUT & VISUALS
-------------------
- Structure: A flex-column container (h-100dvh).
  1. Header: Fixed height. Contains Score and ALL action buttons (defined below).
  2.  Game Area: Flex-1, overflow-y: auto. Critical: This container MUST have the class flex (display: flex) so that its children (the two columns) automatically stretch to fill the full available height of the viewport.
- Columns: Two columns (50% width). 
  - CSS Logic: You MUST apply flex flex-col justify-between to each column. CRITICAL: Instead of min-h-full, you MUST use min-h-[calc(100dvh-6.0rem)]. (This logic ensures the columns are always at least the height of the viewport minus the Header/Footer, forcing justify-between to spread the cards evenly).
  - Behavior: This ensures cards are spaced evenly vertically to occupy the full height of the container when they don't overflow, while still allowing scrolling if content is dense.
  - Content: Left = English, Right = _LANGUAGE.
- Card Content (Strict):
   - Left (English) Card: Display the English text.
   - Right (_LANGUAGE) Card: Display the _LANGUAGE translation.
   - Card Styling (Strict): You must use p-2 (0.5rem) padding and leading-tight for line height. Do NOT apply any fixed height, min-height, or vertical flex-grow to the cards. The card's white background must tightly 'hug' the text content.
   - All cards must use dense padding (Tailwind p-1.5 or p-2) and tight line-height (leading-tight) to strictly minimize vertical whitespace within the card itself.
- Mobile View: The entire UI must fit on a single screen without horizontal scrolling. Vertical scrolling is allowed but should be minimized by the `justify-between` logic where possible.
- Desktop: Set CSS width (viewport) to 400px.
  3. Footer: Fixed height. Contains Copyright (defined below).


5. INTERACTION & EVENTS (STRICT CONSTRAINTS)
--------------------------------------------
You must implement two completely separate event handling systems. Do not unify them.

System A: Desktop (Mouse)
- Draggable Attribute: You MUST conditionally set `draggable={!isTouch}`. Detect touch capability on mount. If the device is touch-enabled, `draggable` MUST be false. This is critical to prevent the native "Long Press to Drag" behavior on mobile.
- Events: Use `onDragStart` and `onDrop`.
- PROHIBITED: Do NOT use `onMouseDown` or `onMouseMove` for dragging logic on Desktop.

System B: Mobile (Touch) - ROBUST IMPLEMENTATION
- CSS Requirement: You MUST apply `touch-action: none;` to the .game-card class. This is non-negotiable to prevent browser scrolling.
- Logic Pattern: Use the "Global Window Listener" pattern.
  1. Trigger: Use the React `onTouchStart` prop on the Card element.
  2. Inside `onTouchStart`:
     a. Call `e.preventDefault()` IMMEDIATELY. This prevents the browser from taking over the gesture.
     b. Check for Double Tap (Guard Clause).
     c. Create the visual CLONE appended to document.body (fixed position, z-index 9999, pointer-events: none). CRITICAL: You MUST explicitly set clone.style.width to match the source element's offsetWidth (px) and set background: white.
     d. Store the initial touch coordinates.
     e. MANUALLY attach native listeners to the window:
        - `window.addEventListener('touchmove', activeTouchMove, { passive: false });`
        - `window.addEventListener('touchend', activeTouchEnd);`
  3. The `activeTouchMove` function:
     a. Updates the Clone's `style.top` and `style.left`.
     b. Updates the Clone's position. CRITICAL: Set style.top to (touch.clientY - 80) + 'px'. This negative offset ensures the card floats ABOVE the finger, making it visible to the user. Set style.left to touch.clientX (centered).
  4. The `activeTouchEnd` function:
     a. Removes the window event listeners immediately.
     b. Removes the Clone from the DOM.
     c. Calculates the drop target using `document.elementFromPoint()`.
     d. Triggers the logic by reading dataset.id. CRITICAL: Do NOT attempt to call methods on the DOM element. Call handleMatch(id) or handleFail(id) directly.
  5. Cleanup: Ensure listeners are removed even if the component unmounts.

Do NOT use a custom hook (e.g., useDoubleTap) inside the .map loop.
Implementation: Use a single useRef at the component level to store { id: null, time: 0 }.
Logic:
1.  Desktop: Use the native React onDoubleClick prop on the card. (Do not use the custom timestamp logic for Desktop; it conflicts with Dragging).
2. Mobile: Handle logic at the very top of `onTouchStart` as a Guard Clause.
   - Check if `id === ref.current.id` and `Date.now() - ref.current.time < 300`.
   - IF YES (Double Tap): 
     a) Trigger the hint.
     b) Reset the ref to { id: null, time: 0 }.
     c) Call `e.preventDefault()`.
     d) RETURN IMMEDIATELY. (Do not execute the card creation or drag logic).
   - IF NO: 
     a) Update the ref with { id, time: Date.now() }.
     b) Proceed to execute the standard Card/Drag logic.

6. GAME LOGIC
-------------
- Matching: Drag English to _TARGET_LANGUAGE.
- SUCCESS: IDs match -> Flash Green 1 second -> _TARGET_LANGUAGE text is spoken (if no hint was given for this card) -> Cards Collapse/Slide Up -> Update Score (+10 + Streak Bonus)..
  0 Persistence: On every successful match (handleMatch), immediately update `localStorage`. 
  1. Add the matched ID to the list of `learnedIds` (merge with existing).
  2. Save the new `score` and `streak`.
  3. This ensures that if the user closes the app mid-game, their progress is not lost.
  4. Streak bonus: equal to the length of the streak.
- FAIL: IDs mismatch -> Play Buzzer -> Flash Red -> Reset Streak -> Deduct Score (-5).
- HINTS:
  - Input: Triggered via the manual Double-Click/Tap logic defined in Section 5.
  - Visuals: The *_TARGET_LANGUAGE* card with that ID flashes bright Orange. The English card does NOT change color.
  - No points awarded for this word if hint is used.
  - The match is not considered successful, the card that was double-clicked remains in play.
  - Effect: Set a global state `hintTargetId`. The *_TARGET_LANGUAGE* card with that ID flashes Orange for 2 seconds. The English card does NOT change color. The _TARGET_LANGUAGE card is spoken.


7. AUDIO SYSTEM (SMART HYBRID)
------------------------------
- API: Hybrid System (Pre-hydrated Audio -> Fallback to window.speechSynthesis).
- Immutable Allow-List: const HQ_LANGS = ['EN', 'ES', 'FR', 'DE', 'IT', 'PT', 'RU', 'ZH', 'JA', 'KO'];
- Initialization Logic (Must run before Component render):
  1. Detect Context: const isEnglishBrowser = navigator.language.toLowerCase().includes('en');
  2. Directionality (Determine Locale):
     - IF isEnglishBrowser is TRUE:
       -> Target: The Foreign Language.
       -> Locale: 'uk-UA' (Map LANGUAGE_CODE 'UK' to 'uk-UA').
     - ELSE (isEnglishBrowser is FALSE):
       -> Target: English.
       -> Locale: Force 'en-US'.
  3. Derive Global State: 
     const AUDIO_ENABLED = HQ_LANGS.some(lang => Locale.toUpperCase().startsWith(lang)) || RAW_DATA.some(item => item.audio !== null);
- Implementation (speakCard(item)):
  1. Strict Guard: If !AUDIO_ENABLED, return immediately.
  2. Execution:
     - IF isEnglishBrowser is TRUE (Foreign Target):
       a. Priority 1 (Hydrated): Check item.audio. If not null, create new Audio(item.audio).play() and return.
       b. Priority 2 (Synthesis Fallback): 
          - Check if browser has voice for Locale. 
          - If YES: Speak item.translation.
          - If NO: Fail silently (Do not crash).
     - ELSE (English Target):
       a. Synthesis Only: Speak item.text (Locale 'en-US').


8. HEADER & POPUPS
------------------
- Header Layout: Single line, compressed. CSS width (viewport): 400px
- Header Elements (Must include ALL of the following):
  0. "openlang.ai" (bold linked to "/")  
  1. Score Display: "Score X (Learned Y%)".
  2. Mute Button: The exact text "MUTE". Toggles `isMuted` state, mutes all sound, text toggles to "UNMUTE". 
  3. Source Button: Button in the upper right corner (strict), strict Link <a href="/_TARGET_LANGUAGE/_GAME/build-instructions.txt" download>SOURCE</a>. Reset all data in local store.
  4. Info icon (large question mark, inside black circle): Opens Info modal.
- Info Modal: 
    - Explain rules in detail (point scoring for correct and penalty for wrong answer, streak bonus = length of the streak, hint rules, no points when hint is used, hint resets streak, game is won when all cards are guessed).
    - Closing: Add a global `window.addEventListener('keydown')` to close modal when "Escape" is pressed or on any tap or mouse click.
- Buttons: Uniform color (Blue).


9. DEBUGGING & SAFETY (CRITICAL)
---------------------------------
To prevent "Blank Screen" errors, you MUST implement a global error handler at the VERY TOP of the <script> tag (before any React code or const definitions).
Code to insert:
window.onerror = function(message, source, lineno, colno, error) {
    document.body.innerHTML = '<div style="background:white;color:red;padding:20px;font-family:sans-serif;"><h1>Application Error</h1><p>' + message + '</p><p>Line: ' + lineno + '</p></div>';
};
For the PWA Icon:
   - Ensure it is defined as a single-line string (no concatenation).


10. STRICT CODE ORGANIZATION (NON-NEGOTIABLE)
----------------------------------------------
To ensure consistency and prevent Scope/Reference errors, you MUST structure the <script> tag in this EXACT order:

1. Global Error Handler (window.onerror).
2. Global Constants & Config (RAW_DATA, CONFIG, AUDIO_ENABLED).
3. PWA Assets (Define `const pwaIcon` first, THEN the manifest blob logic).
4. Pure Helper Functions (shuffle, getDerangement) - defined OUTSIDE the component.
5. The Main Component (`const App = () => { ... }`):
   a. State Definitions (`useState`).
   b. Refs (`useRef`).
   c. Initial Effect (`useEffect` for mounting/loading storage).
   d. Core Logic Functions (`startRound`, `saveProgress`, `speakCard`).
   e. Interaction Handlers (`handleMatch`, `handleFail` - defined INSIDE component).
   f. Event Wrappers (`onTouchStart`, `onDragStart` - defined INSIDE component).
   g. The JSX Return.
6. ReactDOM.createRoot / render.

11. COPYRIGHT (Footer)
---------------------
Place the copyright text verbatim in the Footer (small print, centered):
- Link "Functional AI Inc" to: https://functional.by
- Link "MIT License" to: https://opensource.org/licenses/MIT

"Copyright (c) 2026 by Functional AI Inc. Licensed under the MIT License."

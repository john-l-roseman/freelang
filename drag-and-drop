Act as an expert Frontend Engineer. 
Build a single, standalone HTML file (index.html) for a language learning game.
IMPORTANT: Do not add any notes, markdown, or explanations at the top or bottom of the HTML file. Output ONLY the raw HTML.

1. GLOBAL CONFIGURATION
-----------------------
- CARDS_PER_ROUND: _CARD_COUNT
- BASE_LANGUAGE: _BASE_LANGUAGE
- TARGET_LANGUAGE: _TARGET_LANGUAGE
- LANGUAGE_CODE: Two letter standard code for _TARGET_LANGUAGE (All Caps).
- GA_MEASUREMENT_ID: "G-WFWF326Q9H"  


2. TECHNICAL STACK & SETUP
--------------------------
- React, ReactDOM, Babel (via CDN).
- TailwindCSS (via CDN).
- Embed all CSS/JS within the file.
- Analytics: Include the standard Google Analytics 4 (gtag.js) script in the <head>. Initialize `window.dataLayer` and config using the `GA_MEASUREMENT_ID`. 
- PWA: Include an embedded `manifest.json` (Blob) and Service Worker.
- PWA Icon: Generate a Base64 SVG (Green square, white text "LANGUAGE_CODE") for the manifest. Short name: "_GAME".


3. ARCHITECTURE & STATE MANAGEMENT (CRITICAL)
---------------------------------------------
- Storage Key: Use const `STORAGE_KEY = 'openlang__TARGET_LANGUAGE__GAME_STRING_progress'`.
- Persistence Schema: `{ score: number, streak: number, learnedIds: [] }`.
- Initialization Logic (Order of Operations):
  1. On mount, read `localStorage`.
  2. If data exists, hydrate `score` and `streak` state from it.
  3. Filter `RAW_DATA` to exclude any IDs found in `learnedIds`.
  4. Initialize `deckRef` using a Fisher-Yates shuffle of the *remaining* (unlearned) items.
  5. If no items remain (all learned), trigger the Win Condition immediately.
- Round State: Use `useState` only for the current CARDS_PER_ROUND pairs.
- Mastery Logic: When a match is made (no hint), remove the word from `deckRef.current` immediately.
- Round Transition: When last pair matches, slice next batch from `deckRef`.
- _LANGUAGE Column Logic: Must be a VALID DERANGEMENT (shuffled so no _LANGUAGE card lines up horizontally with its English counterpart). If batch size < 2, return as-is.


4. LAYOUT & VISUALS
-------------------
- Structure: A flex-column container (h-100dvh).
  1. Header: Fixed height. Contains Score and ALL action buttons (defined below).
  2. Game Area: Flex-1, overflow-y: auto. Contains the two card columns.
- Columns: Two columns (50% width). Left = English, Right = _TARGET_LANGUAGE.
- Card Content (Strict):
   - Left (English) Card: Display the English text.
   - Right (_LANGUAGE) Card: Display the _LANGUAGE translation.
- Animations: Use a `.card-wrapper` class. On match, transition `max-height`, `opacity`, and `margin` to 0 to make cards slide up smoothly.
- Mobile View: The entire UI must fit on a single screen without horizontal scrolling.
- Desktop: Set CSS width (viewport) to 400px.
  3. Footer: Fixed height. Contains Copyright (defined below).

5. INTERACTION & EVENTS (STRICT CONSTRAINTS)
--------------------------------------------
You must implement two completely separate event handling systems. Do not unify them.

System A: Desktop (Mouse)
- Draggable Attribute: You MUST conditionally set `draggable={!isTouch}`. Detect touch capability on mount. If the device is touch-enabled, `draggable` MUST be false. This is critical to prevent the native "Long Press to Drag" behavior on mobile.
- Events: Use `onDragStart` and `onDrop`.
- PROHIBITED: Do NOT use `onMouseDown` or `onMouseMove` for dragging logic on Desktop.

System B: Mobile (Touch)
- Events: Use `onTouchStart`, `onTouchMove`, `onTouchEnd`.
- Drag Logic (CLONE METHOD): 
  1. On `onTouchStart`, create a visual CLONE of the card. 
  2. Append this clone to the document `<body>`.
  3. Style the clone with `position: fixed`, `z-index: 9999`, `pointer-events: none`, and `opacity: 0.8`.
  4. The Original Card MUST remain in the column (do not hide it, do not move it).
- Movement: Update the `top/left` CSS properties of the CLONE during `onTouchMove` to follow the finger.
- Event Propagation: Inside onTouchStart, if a valid drag is detected (and it is not a double-tap), you MUST call e.preventDefault() to lock the native scroll immediately, followed by e.stopPropagation().
- CSS Safety: Apply touch-action: none AND -webkit-touch-callout: none to the .game-card class. You must also apply user-select: none to the body or container to prevent text selection during drag.
- Cleanup: Remove the clone from the DOM on `onTouchEnd`.
- Scroll Locking: You MUST call e.preventDefault() inside onTouchMove. This is critical to stop the browser viewport from scrolling while the user is dragging the clone card.

Double-Tap Implementation (CRITICAL):
Do NOT use a custom hook (e.g., useDoubleTap) inside the .map loop.
Implementation: Use a single useRef at the component level to store { id: null, time: 0 }.
Logic:
1. Desktop: Handle logic inside the standard `onClick` event.
2. Mobile: Handle logic at the very top of `onTouchStart` as a Guard Clause.
   - Check if `id === ref.current.id` and `Date.now() - ref.current.time < 300`.
   - IF YES (Double Tap): 
     a) Trigger the hint.
     b) Reset the ref to { id: null, time: 0 }.
     c) Call `e.preventDefault()`.
     d) RETURN IMMEDIATELY. (Do not execute the card creation or drag logic).
   - IF NO: 
     a) Update the ref with { id, time: Date.now() }.
     b) Proceed to execute the standard Card/Drag logic.

6. GAME LOGIC
-------------
- Matching: Drag English to _TARGET_LANGUAGE.
- Success: IDs match -> Flash Green 1 second -> _TARGET_LANGUAGE text is spoken (if no hint was given for this card) -> Cards Collapse/Slide Up -> Update Score.
- Fail: IDs mismatch -> Play Buzzer -> Flash Red -> Reset Streak -> Deduct Score.
- Hints:
  - Input: Triggered via the manual Double-Click/Tap logic defined in Section 5.
  - Visuals: The *_TARGET_LANGUAGE* card with that ID flashes bright Orange. The English card does NOT change color.
  - Penalty: No points awarded for this word if hint is used.
  - Effect: Set a global state `hintTargetId`. The *_TARGET_LANGUAGE* card with that ID flashes Orange for 2 seconds. The English card does NOT change color. The _TARGET_LANGUAGE card is spoken.
  - Persistence: On every successful match (handleMatch), immediately update `localStorage`. 
  1. Add the matched ID to the list of `learnedIds` (merge with existing).
  2. Save the new `score` and `streak`.
  3. This ensures that if the user closes the app mid-game, their progress is not lost.
- Reset Option: Add a hidden mechanism or check (e.g., if `RAW_DATA` version changes) to clear storage, but for now, assume permanent storage until the user clears browser cache.


7. AUDIO SYSTEM (SMART AUTO-DETECT)
-----------------------------------
- API: `window.speechSynthesis`.
- Configuration:
  1. Define a strict allow-list: `const HQ_LANGS = ['EN', 'ES', 'FR', 'DE', 'IT', 'PT', 'RU', 'ZH', 'JA', 'KO'];`
  2. Derive Global State: `const AUDIO_ENABLED = HQ_LANGS.includes(LANGUAGE_CODE);`
- Implementation Logic (`speakCard` function):
  1. Strict Guard: If `!AUDIO_ENABLED`, return immediately (do not run any Speech logic).
  2. User Context: Detect `const isEnglishBrowser = navigator.language.toLowerCase().includes('en');`
  3. Directionality (If Enabled):
     - IF `isEnglishBrowser` is TRUE: 
       -> Target: The Foreign Language (the `translation` field).
       -> Locale: Map `LANGUAGE_CODE` to standard BCP-47 (e.g. 'RU'->'ru-RU', 'CN'->'zh-CN', 'BE'->'be-BY').
     - ELSE (`isEnglishBrowser` is FALSE):
       -> Target: English (the `text` field).
       -> Locale: Force 'en-US'.
  4. Runtime Safety:
     - Check `window.speechSynthesis.getVoices()` for the required Locale.
     - If the specific voice is missing on the device, fail silently (catch errors).
     - Filter for `localService: true` voices if available for lower latency.


8. HEADER & POPUPS
------------------
- Header Layout: Single line, compressed.
- Header Elements (Must include ALL of the following):
  0. "openlang.ai" (bold linked to "/")  
  1. Score Display: "Score X (Learned Y%)".
  2. Mute Button: The exact text "MUTE". Toggles `isMuted` state, mutes all sound, text toggles to "UNMUTE". 
  3. Info icon (large question mark, inside black circle): Opens Info modal.
  5. Source Button: Button in the upper right corner (strict), strict Link `<a href="/_TARGET_LANGUAGE/_GAME/build-instructions.txt" download>SOURCE</a>`.
- Info Modal: 
1. Explain rules (point scoring for correct and penalty for wrong answer, streak bonus, hint rules, no points for hint).
2. Describe how to install on mobile: iOS: share icon (show the iOS share icon) -> Add to Home Screen; Android: "Three dot menu -> Add to Home Screen [or click INSTALL if available below]".
3. Add a button "INSTALL" at the bottom that is hidden by default. You only show that button if the browser says the app is installable. The INSTALL button launches the install process on Android phones where automatic PWA install is supported.
- Closing: Add a global `window.addEventListener('keydown')` to close all modals when "Escape" is pressed.
- Buttons: Uniform color (Blue).


9. COPYRIGHT (Footer)
---------------------
Place the copyright text verbatim in the Footer (small print, centered):
- Link "Functional AI Inc" to: https://functional.by
- Link "MIT License" to: https://opensource.org/licenses/MIT

"Copyright (c) 2026 by Functional AI Inc. Licensed under the MIT License."

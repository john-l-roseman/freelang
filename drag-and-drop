Act as an expert Frontend Engineer. 
Build a single, standalone HTML file (index.html) for a language learning game.
IMPORTANT: Do not add any notes, markdown, or explanations at the top or bottom of the HTML file. Output ONLY the raw HTML.

1. GLOBAL CONFIGURATION
-----------------------
- CARDS_PER_ROUND: _CARD_COUNT
- BASE_LANGUAGE: _BASE_LANGUAGE
- TARGET_LANGUAGE: _TARGET_LANGUAGE
- LANGUAGE_CODE: Two letter standard code for _TARGET_LANGUAGE (All Caps).
- GA_MEASUREMENT_ID: "G-WFWF326Q9H"  


2. TECHNICAL STACK & SETUP
--------------------------
- React, ReactDOM, Babel (via CDN).
- TailwindCSS (via CDN).
- Embed all CSS/JS within the file.
- Analytics: Include the standard Google Analytics 4 (gtag.js) script in the <head>. Initialize `window.dataLayer` and config using the `GA_MEASUREMENT_ID`. 
- PWA: Include an embedded `manifest.json` (Blob) and Service Worker.
- PWA Icon: Generate a Base64 SVG (Green square, white text "LANGUAGE_CODE") for the manifest. Short name: "_GAME".
- Cache Control: You MUST include the following three <meta> tags in the <head> to prevent client-side caching:
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">


3. ARCHITECTURE & STATE MANAGEMENT (CRITICAL)
---------------------------------------------
- Storage Key: Use const `STORAGE_KEY = 'openlang__LANGUAGE__GAME'`.
- Persistence Schema: `{ score: number, streak: number, learnedIds: [] }`.
- Initialization Logic (Order of Operations):
  1. On mount, read `localStorage`.
  2. If data exists, hydrate `score` and `streak` state from it.
  3. Filter `RAW_DATA` to exclude any IDs found in `learnedIds`.
  4. Initialize `deckRef` using a Fisher-Yates shuffle of the *remaining* (unlearned) items.
  5. If no items remain (all learned), trigger the Win Condition immediately.
  6. If items remain, call `startRound()` to load the first batch.
- Round State: Use `useState` (`roundData`) for the current CARDS_PER_ROUND pairs.
- Mastery Logic: When a match is made (no hint), remove the word from `deckRef.current` immediately.
- Round Transition (useEffect Pattern): 
  - You MUST use a `useEffect` hook to handle transitions. Do NOT trigger the next round inside `handleMatch`.
  - Watch dependency: `[roundData.left.length, isWon]`.
  - Logic: IF `roundData.left.length === 0` AND `!isWon` AND `deckRef.current` is initialized:
    a. Check if `deckRef.current.length > 0`.
    b. If YES: Call `startRound()`.
    c. If NO: Set `isWon(true)`.
- _LANGUAGE Column Logic: Must be a VALID DERANGEMENT (shuffled so no _LANGUAGE card lines up horizontally with its English counterpart). If batch size < 2, return as-is.


4. LAYOUT & VISUALS
-------------------
- Structure: A flex-column container (h-100dvh).
  1. Header: Fixed height. Contains Score and ALL action buttons (defined below).
  2.  Game Area: Flex-1, overflow-y: auto. Critical: This container MUST have the class flex (display: flex) so that its children (the two columns) automatically stretch to fill the full available height of the viewport.
- Columns: Two columns (50% width). 
  - CSS Logic: You MUST apply flex flex-col justify-between to each column. CRITICAL: Instead of min-h-full, you MUST use min-h-[calc(100dvh-5.5rem)]. (This logic ensures the columns are always at least the height of the viewport minus the Header/Footer, forcing justify-between to spread the cards evenly).
  - Behavior: This ensures cards are spaced evenly vertically to occupy the full height of the container when they don't overflow, while still allowing scrolling if content is dense.
  - Content: Left = English, Right = French.
- Card Content (Strict):
   - Left (English) Card: Display the English text.
   - Right (_LANGUAGE) Card: Display the _LANGUAGE translation.
   - Card Styling (Strict): You must use p-2 (0.5rem) padding and leading-tight for line height. Do NOT apply any fixed height, min-height, or vertical flex-grow to the cards. The card's white background must tightly 'hug' the text content.
   - All cards must use dense padding (Tailwind p-1.5 or p-2) and tight line-height (leading-tight) to strictly minimize vertical whitespace within the card itself.
- Mobile View: The entire UI must fit on a single screen without horizontal scrolling. Vertical scrolling is allowed but should be minimized by the `justify-between` logic where possible.
- Desktop: Set CSS width (viewport) to 400px.
  3. Footer: Fixed height. Contains Copyright (defined below).


5. INTERACTION & EVENTS (STRICT CONSTRAINTS)
--------------------------------------------
You must implement two completely separate event handling systems.
SHARED IMPLEMENTATION DETAILS:
- Do NOT use a custom hook (e.g., useDoubleTap).
- State: Use a single `useRef` at the component level: `const touchRef = useRef({ id: null, time: 0 });`

System A: Desktop (Mouse)
- Draggable Attribute: Conditionally set `draggable={!isTouch}`. 
- Events: 
  1. Use `onDragStart` and `onDrop`.
  2. Use the native `onDoubleClick` prop to trigger `handleHint(id)`.
- PROHIBITED: Do NOT use `onMouseDown` or `onMouseMove`.

System B: Mobile (Touch) - ROBUST IMPLEMENTATION
- CSS Requirement: Apply `touch-action: none;` to the .game-card class.
- Logic Pattern: Use the "Global Window Listener" pattern.
  1. Trigger: Use `onTouchStart` on the Card element.
  2. Guard Clause (Double Tap Detection):
     - Check if `id === touchRef.current.id` AND `Date.now() - touchRef.current.time < 300`.
     - IF YES (It is a Double Tap):
       a. Call `handleHint(id)`.
       b. Reset ref to `{ id: null, time: 0 }`.
       c. Call `e.preventDefault()`.
       d. CRITICAL: return; (STOP EXECUTION IMMEDIATELY. Do not run any drag logic).
     - IF NO:
       a. Update ref to `{ id, time: Date.now() }`.
       b. Proceed to Step 3.
  3. Drag Logic (Only runs if Step 2 did not return):
     a. Call `e.preventDefault()`.
     b. Create the visual CLONE (fixed position, z-index 9999, pointer-events: none, background: white, width: source width).
     c. MANUALLY attach native listeners (`touchmove`, `touchend`) to the window.
  4. The `activeTouchMove` function:
     - Updates clone position to `touch.clientY - 80` (offset for visibility) and `touch.clientX`.
  5. The `activeTouchEnd` function:
     a. Removes the window event listeners immediately.
     b. Removes the Clone from the DOM.
     c. Calculates drop target using `document.elementFromPoint()`.
     d. Logic: IF target is found AND target ID != source ID, call `handleMatch` or `handleFail`. IF target ID == source ID (user just tapped), do NOTHING.


6. GAME LOGIC
-------------
- Matching: Drag English to Ukrainian.
- Success: IDs match -> Flash Green 1 second -> Ukrainian text is spoken (if no hint was given for this card) -> Cards Collapse/Slide Up -> Update Score (+10 + Streak Bonus).
- Streak bonus: equal to the length of the streak.
- Fail: IDs mismatch -> Play Buzzer -> Flash Red -> Reset Streak -> Deduct Score (-5).
- Hints:
  - Input: Triggered via the Double-Click (Desktop) or Double-Tap (Mobile) logic defined in Section 5.
  - Logic Constraint (CRITICAL): The `handleHint` function MUST be "Read Only". It must NEVER remove cards, NEVER award points, and NEVER trigger `handleMatch`.
  - Visuals: The *Ukrainian* card with that ID flashes bright Orange for 2 seconds. The English card does NOT change color.
  - Effect: Set a global state `hintTargetId`. Speak the Ukrainian text immediately.
  - Penalty: Reset Streak to 0. Mark this specific Card ID as "hinted" in state so that 0 points are awarded when it is eventually matched.
- Persistence: On every successful match (handleMatch), immediately update `localStorage`. 
  1. Add the matched ID to the list of `learnedIds` (merge with existing).
  2. Save the new `score` and `streak`.
  3. This ensures that if the user closes the app mid-game, their progress is not lost.
- Reset Option: Add a hidden mechanism or check (e.g., if `RAW_DATA` version changes) to clear storage, but for now, assume permanent storage until the user clears browser cache.


7. AUDIO SYSTEM (SMART AUTO-DETECT)
-----------------------------------
- API: `window.speechSynthesis`.
- Configuration:
  1. Immutable Allow-List: `const HQ_LANGS = ['EN', 'ES', 'FR', 'DE', 'IT', 'PT', 'RU', 'ZH', 'JA', 'KO'];`
  2. STRICT CONSTRAINT: You are PROHIBITED from modifying `HQ_LANGS`. Do NOT add the target language to this array. Output the array exactly as written above.
  3. Derive Global State: `const AUDIO_ENABLED = HQ_LANGS.includes(LANGUAGE_CODE);`
- Implementation Logic (`speakCard` function):
  1. Strict Guard: If `!AUDIO_ENABLED`, return immediately (do not run any Speech logic).
  2. User Context: Detect `const isEnglishBrowser = navigator.language.toLowerCase().includes('en');`
  3. Directionality (If Enabled):
     - IF `isEnglishBrowser` is TRUE: 
       -> Target: The Foreign Language.
       -> Locale: Map `LANGUAGE_CODE` to standard BCP-47.
     - ELSE (`isEnglishBrowser` is FALSE):
       -> Target: English.
       -> Locale: Force 'en-US'.
  4. Runtime Safety:
     - Check `window.speechSynthesis.getVoices()` for the required Locale.
     - If the specific voice is missing on the device, fail silently.


8. HEADER & POPUPS
------------------
- Header Layout: Single line, compressed. CSS width (viewport): 400px
- Header Elements (Must include ALL of the following):
  0. "openlang.ai" (bold linked to "/")  
  1. Score Display: "Score X (Learned Y%)".
  2. Mute Button: The exact text "MUTE". Toggles `isMuted` state, mutes all sound, text toggles to "UNMUTE". 
  3. Info icon (large question mark, inside black circle): Opens Info modal.
  4. Download icon: Launch PWA install process. Display only on Android.
  5. Source Button: Button in the upper right corner (strict), strict Link `<a href="/_TARGET_LANGUAGE/_GAME/build-instructions.txt" download>SOURCE</a>`.
- Info Modal: 
    - Explain rules in detail (point scoring for correct and penalty for wrong answer, streak bonus = length of the streak, hint rules, no points when hint is used, hint resets streak, game is won when all cards are guessed).
    - Closing: Add a global `window.addEventListener('keydown')` to close modal when "Escape" is pressed.
- Buttons: Uniform color (Blue).


9. DEBUGGING & SAFETY (CRITICAL)
---------------------------------
To prevent "Blank Screen" errors, you MUST implement a global error handler at the VERY TOP of the <script> tag (before any React code or const definitions).
Code to insert:
window.onerror = function(message, source, lineno, colno, error) {
    document.body.innerHTML = '<div style="background:white;color:red;padding:20px;font-family:sans-serif;"><h1>Application Error</h1><p>' + message + '</p><p>Line: ' + lineno + '</p></div>';
};
For the PWA Icon:
   - Ensure it is defined as a single-line string (no concatenation).


10. STRICT CODE ORGANIZATION (NON-NEGOTIABLE)
----------------------------------------------
To ensure consistency and prevent Scope/Reference errors, you MUST structure the <script> tag in this EXACT order:

1. Global Error Handler (window.onerror).
2. Global Constants & Config (RAW_DATA, CONFIG, AUDIO_ENABLED).
3. PWA Assets (Define `const pwaIcon` first, THEN the manifest blob logic).
4. Pure Helper Functions (shuffle, getDerangement) - defined OUTSIDE the component.
5. The Main Component (`const App = () => { ... }`):
   a. State Definitions (`useState`).
   b. Refs (`useRef`).
   c. Initial Effect (`useEffect` for mounting/loading storage).
   d. Core Logic Functions (`startRound`, `saveProgress`, `speakCard`).
   e. Interaction Handlers (`handleMatch`, `handleFail` - defined INSIDE component).
   f. Event Wrappers (`onTouchStart`, `onDragStart` - defined INSIDE component).
   g. The JSX Return.
6. ReactDOM.createRoot / render.

11. COPYRIGHT (Footer)
---------------------
Place the copyright text verbatim in the Footer (small print, centered):
- Link "Functional AI Inc" to: https://functional.by
- Link "MIT License" to: https://opensource.org/licenses/MIT

"Copyright (c) 2026 by Functional AI Inc. Licensed under the MIT License."

Act as an expert Frontend Engineer. 
Build a single, standalone HTML file (index.html) for a language learning game.
IMPORTANT: Do not add any notes, markdown, or explanations at the top or bottom of the HTML file. Output ONLY the raw HTML.

1. GLOBAL CONFIGURATION
-----------------------
- CARDS_PER_ROUND: _CARD_COUNT
- BASE_LANGUAGE: _BASE_LANGUAGE
- TARGET_LANGUAGE: _TARGET_LANGUAGE
- LANGUAGE_CODE: Two letter standard code for _TARGET_LANGUAGE (All Caps).
- GA_MEASUREMENT_ID: "G-WFWF326Q9H"  


2. TECHNICAL STACK & SETUP
--------------------------
- React, ReactDOM, Babel (via CDN).
- TailwindCSS (via CDN).
- Embed all CSS/JS within the file.
- Analytics: Include the standard Google Analytics 4 (gtag.js) script in the <head>. Initialize `window.dataLayer` and config using the `GA_MEASUREMENT_ID`. 
- PWA: Include an embedded `manifest.json` (Blob) and Service Worker.
- PWA Icon: Generate a Base64 SVG (Green square, white text "LANGUAGE_CODE") for the manifest. Short name: "_GAME".


3. ARCHITECTURE & STATE MANAGEMENT (CRITICAL)
---------------------------------------------
- Storage Key: Use const `STORAGE_KEY = 'openlang__TARGET_LANGUAGE__GAME_STRING_progress'`.
- Persistence Schema: `{ score: number, streak: number, learnedIds: [] }`.
- Initialization Logic (Order of Operations):
  1. On mount, read `localStorage`.
  2. If data exists, hydrate `score` and `streak` state from it.
  3. Filter `RAW_DATA` to exclude any IDs found in `learnedIds`.
  4. Initialize `deckRef` using a Fisher-Yates shuffle of the *remaining* (unlearned) items.
  5. If no items remain (all learned), trigger the Win Condition immediately.
- Round State: Use `useState` only for the current CARDS_PER_ROUND pairs.
- Mastery Logic: When a match is made (no hint), remove the word from `deckRef.current` immediately.
- Round Transition: When last pair matches, slice next batch from `deckRef`.
- _LANGUAGE Column Logic: Must be a VALID DERANGEMENT (shuffled so no _LANGUAGE card lines up horizontally with its English counterpart). If batch size < 2, return as-is.


4. LAYOUT & VISUALS
-------------------
- Structure: A flex-column container (h-100dvh).
  1. Header: Fixed height. Contains Score and ALL action buttons (defined below).
  2. Game Area: Flex-1, overflow-y: auto. Contains the two card columns.
- Columns: Two columns (50% width). Left = English, Right = _TARGET_LANGUAGE.
- Card Content (Strict):
   - Left (English) Card: Display the English text.
   - Right (_LANGUAGE) Card: Display the _LANGUAGE translation.
   - Card Styling (Strict): You must use p-2 (0.5rem) padding and leading-tight for line height. Do NOT apply any fixed height, min-height, or vertical flex-grow to the cards. The card's white background must tightly 'hug' the text content with no extra vertical spacing.
   - All cards must use dense padding (Tailwind p-1.5 or p-2) and tight line-height (leading-tight) to strictly minimize vertical whitespace.
- Animations: Use a `.card-wrapper` class. On match, transition `max-height`, `opacity`, and `margin` to 0 to make cards slide up smoothly.
- Mobile View: The entire UI must fit on a single screen without horizontal or vertical scrolling.
- Desktop: Set CSS width (viewport) to 400px.
  3. Footer: Fixed height. Contains Copyright (defined below).

5. INTERACTION & EVENTS (STRICT CONSTRAINTS)
--------------------------------------------
You must implement two completely separate event handling systems. Do not unify them.

System A: Desktop (Mouse)
- Draggable Attribute: You MUST conditionally set `draggable={!isTouch}`. Detect touch capability on mount. If the device is touch-enabled, `draggable` MUST be false. This is critical to prevent the native "Long Press to Drag" behavior on mobile.
- Events: Use `onDragStart` and `onDrop`.
- PROHIBITED: Do NOT use `onMouseDown` or `onMouseMove` for dragging logic on Desktop.

System B: Mobile (Touch) - ROBUST IMPLEMENTATION
- CSS Requirement: You MUST apply `touch-action: none;` to the .game-card class. This is non-negotiable to prevent browser scrolling.
- Logic Pattern: Use the "Global Window Listener" pattern.
  1. Trigger: Use the React `onTouchStart` prop on the Card element.
  2. Inside `onTouchStart`:
     a. Call `e.preventDefault()` IMMEDIATELY. This prevents the browser from taking over the gesture.
     b. Check for Double Tap (Guard Clause).
     c. Create the visual CLONE appended to `document.body` (fixed position, z-index 9999).
     d. Store the initial touch coordinates.
     e. MANUALLY attach native listeners to the window:
        - `window.addEventListener('touchmove', activeTouchMove, { passive: false });`
        - `window.addEventListener('touchend', activeTouchEnd);`
  3. The `activeTouchMove` function:
     a. Must be defined outside or memoized (to be removable).
     b. Updates the Clone's `style.top` and `style.left`.
  4. The `activeTouchEnd` function:
     a. Removes the window event listeners immediately.
     b. Removes the Clone from the DOM.
     c. Calculates the drop target using `document.elementFromPoint()`.
     d. Triggers the match/fail logic.
  5. Cleanup: Ensure listeners are removed even if the component unmounts.

Do NOT use a custom hook (e.g., useDoubleTap) inside the .map loop.
Implementation: Use a single useRef at the component level to store { id: null, time: 0 }.
Logic:
1. Desktop: Handle logic inside the standard `onClick` event.
2. Mobile: Handle logic at the very top of `onTouchStart` as a Guard Clause.
   - Check if `id === ref.current.id` and `Date.now() - ref.current.time < 300`.
   - IF YES (Double Tap): 
     a) Trigger the hint.
     b) Reset the ref to { id: null, time: 0 }.
     c) Call `e.preventDefault()`.
     d) RETURN IMMEDIATELY. (Do not execute the card creation or drag logic).
   - IF NO: 
     a) Update the ref with { id, time: Date.now() }.
     b) Proceed to execute the standard Card/Drag logic.

6. GAME LOGIC
-------------
- Matching: Drag English to _TARGET_LANGUAGE.
- Success: IDs match -> Flash Green 1 second -> _TARGET_LANGUAGE text is spoken (if no hint was given for this card) -> Cards Collapse/Slide Up -> Update Score.
- Fail: IDs mismatch -> Play Buzzer -> Flash Red -> Reset Streak -> Deduct Score.
- Hints:
  - Input: Triggered via the manual Double-Click/Tap logic defined in Section 5.
  - Visuals: The *_TARGET_LANGUAGE* card with that ID flashes bright Orange. The English card does NOT change color.
  - Penalty: No points awarded for this word if hint is used.
  - Effect: Set a global state `hintTargetId`. The *_TARGET_LANGUAGE* card with that ID flashes Orange for 2 seconds. The English card does NOT change color. The _TARGET_LANGUAGE card is spoken.
  - Persistence: On every successful match (handleMatch), immediately update `localStorage`. 
  1. Add the matched ID to the list of `learnedIds` (merge with existing).
  2. Save the new `score` and `streak`.
  3. This ensures that if the user closes the app mid-game, their progress is not lost.
- Reset Option: Add a hidden mechanism or check (e.g., if `RAW_DATA` version changes) to clear storage, but for now, assume permanent storage until the user clears browser cache.


7. AUDIO SYSTEM (SMART AUTO-DETECT)
-----------------------------------
- API: `window.speechSynthesis`.
- Configuration:
  1. Define a strict allow-list: `const HQ_LANGS = ['EN', 'ES', 'FR', 'DE', 'IT', 'PT', 'RU', 'ZH', 'JA', 'KO'];`
  2. Derive Global State: `const AUDIO_ENABLED = HQ_LANGS.includes(LANGUAGE_CODE);`
- Implementation Logic (`speakCard` function):
  1. Strict Guard: If `!AUDIO_ENABLED`, return immediately (do not run any Speech logic).
  2. User Context: Detect `const isEnglishBrowser = navigator.language.toLowerCase().includes('en');`
  3. Directionality (If Enabled):
     - IF `isEnglishBrowser` is TRUE: 
       -> Target: The Foreign Language (the `translation` field).
       -> Locale: Map `LANGUAGE_CODE` to standard BCP-47 (e.g. 'RU'->'ru-RU', 'CN'->'zh-CN', 'BE'->'be-BY').
     - ELSE (`isEnglishBrowser` is FALSE):
       -> Target: English (the `text` field).
       -> Locale: Force 'en-US'.
  4. Runtime Safety:
     - Check `window.speechSynthesis.getVoices()` for the required Locale.
     - If the specific voice is missing on the device, fail silently (catch errors).
     - Filter for `localService: true` voices if available for lower latency.


8. HEADER & POPUPS
------------------
- Header Layout: Single line, compressed. CSS width (viewport): 400px
- Header Elements (Must include ALL of the following):
  0. "openlang.ai" (bold linked to "/")  
  1. Score Display: "Score X (Learned Y%)".
  2. Mute Button: The exact text "MUTE". Toggles `isMuted` state, mutes all sound, text toggles to "UNMUTE". 
  3. Info icon (large question mark, inside black circle): Opens Info modal.
  5. Source Button: Button in the upper right corner (strict), strict Link `<a href="/_TARGET_LANGUAGE/_GAME/build-instructions.txt" download>SOURCE</a>`.
- Info Modal: 
1. Explain rules (point scoring for correct and penalty for wrong answer, streak bonus, hint rules, no points for hint).
2. Describe how to install on mobile: iOS: share icon (show the iOS share icon) -> Add to Home Screen; Android: "Three dot menu -> Add to Home Screen [or click INSTALL if available below]".
3. Add a button "INSTALL" at the bottom that is hidden by default. You only show that button if the browser says the app is installable. The INSTALL button launches the install process on Android phones where automatic PWA install is supported.
- Closing: Add a global `window.addEventListener('keydown')` to close all modals when "Escape" is pressed.
- Buttons: Uniform color (Blue).

9. DEBUGGING & SAFETY (CRITICAL)
---------------------------------
To prevent "Blank Screen" errors, you MUST implement a global error handler at the VERY TOP of the <script> tag (before any React code or const definitions).
Code to insert:
window.onerror = function(message, source, lineno, colno, error) {
    document.body.innerHTML = '<div style="background:white;color:red;padding:20px;font-family:sans-serif;"><h1>Application Error</h1><p>' + message + '</p><p>Line: ' + lineno + '</p></div>';
};

Additionally, for the PWA Icon:
- Ensure the `pwaIcon` variable is defined as a single-line string. 
- Do NOT insert line breaks or concatenation (`+`) inside the Base64 string.


10. COPYRIGHT (Footer)
---------------------
Place the copyright text verbatim in the Footer (small print, centered):
- Link "Functional AI Inc" to: https://functional.by
- Link "MIT License" to: https://opensource.org/licenses/MIT

"Copyright (c) 2026 by Functional AI Inc. Licensed under the MIT License."
